ì •í™•íˆ ë§ì”€í•˜ì‹  ìš”ì²­ì„ ì´í•´í–ˆìŠµë‹ˆë‹¤. ë¬¸ì¥ì´ ê¸¸ë©´ ëŠì–´ì„œ ë²ˆì—­í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, **í•œ ë¬¸ì¥ì˜ ë²ˆì—­ ë‚´ìš© ìì²´ë¥¼ ì¤„ë°”ê¿ˆí•˜ì—¬** ë³´ì—¬ë“œë¦¬ëŠ” ë°©ì‹ìœ¼ë¡œ ìˆ˜ì •í•˜ê² ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì²˜ìŒë¶€í„° ìš”ì²­í•˜ì‹  ë°©ì‹ì— ë§ì¶° ì‘ì—…í•˜ê² ìŠµë‹ˆë‹¤.

---

1. **Now besides adding an interceptor  
   that intercepts outgoing requests,  
   you can also build up on that interceptor  
   to also intercept incoming responses.**  
   ì´ì œ, ì „ì†¡ ìš”ì²­ì„ ê°€ë¡œì±„ëŠ”  
   ì¸í„°ì…‰í„°ë¥¼ ì¶”ê°€í•˜ëŠ” ê²ƒ ì™¸ì—ë„,  
   í•´ë‹¹ ì¸í„°ì…‰í„°ë¥¼ í™•ì¥í•˜ì—¬  
   ìˆ˜ì‹ ëœ ì‘ë‹µë„ ê°€ë¡œì±Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

2. **Now for that,  
   you'll always need such a request interceptor  
   because it's then the result of calling next down here,  
   which will allow you to also intercept responses  
   and act on responses**  
   ì´ë¥¼ ìœ„í•´,  
   í•­ìƒ ìš”ì²­ ì¸í„°ì…‰í„°ê°€ í•„ìš”í•©ë‹ˆë‹¤.  
   ì´ëŠ” ì•„ë˜ì—ì„œ `next`ë¥¼ í˜¸ì¶œí•œ ê²°ê³¼ë¡œ,  
   ì‘ë‹µì„ ê°€ë¡œì±„ê³   
   ì‘ë‹µì— ëŒ€í•´ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤.

---

3. **because next will give you an observable  
   that's wrapped around an HTTP event type of value.**  
   `next`ëŠ” HTTP ì´ë²¤íŠ¸ íƒ€ì…ì˜ ê°’ì„  
   ê°ì‹¸ëŠ” Observableì„ ë°˜í™˜í•©ë‹ˆë‹¤.

---

4. **And you can therefore call pipe here  
   since it's an observable to change it or to tap into it.**  
   ë”°ë¼ì„œ Observableì´ë¯€ë¡œ  
   ì—¬ê¸°ì—ì„œ `pipe`ë¥¼ í˜¸ì¶œí•˜ì—¬  
   ì´ë¥¼ ë³€ê²½í•˜ê±°ë‚˜ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

5. **We don't wanna subscribe here  
   because that would be the end of this observable chain  
   and other parts in the application now wouldn't be able  
   to interact with that response anymore.**  
   ì—¬ê¸°ì—ì„œëŠ” `subscribe`ë¥¼ í˜¸ì¶œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.  
   ê·¸ë ‡ê²Œ í•˜ë©´ Observable ì²´ì¸ì´ ì¢…ë£Œë˜ì–´,  
   ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ë‹¤ë¥¸ ë¶€ë¶„ì—ì„œ  
   í•´ë‹¹ ì‘ë‹µê³¼ ìƒí˜¸ì‘ìš©í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

---

6. **So pipe it is instead.  
   And to pipe you can now pass  
   all the operators you learned about.**  
   ë”°ë¼ì„œ ëŒ€ì‹  `pipe`ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.  
   ê·¸ë¦¬ê³  ì—¬ê¸°ì—  
   ë°°ìš´ ëª¨ë“  ì—°ì‚°ìë¥¼ ì „ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

7. **For example, tap to define your own observer  
   that will execute your own code here  
   and here I'll simply wait for the next value to be emitted,  
   which here will actually be of type event  
   because here will actually get an event type of value  
   instead of the response data.**  
   ì˜ˆë¥¼ ë“¤ì–´, `tap`ì„ ì‚¬ìš©í•´  
   ìì‹ ë§Œì˜ ì˜µì €ë²„ë¥¼ ì •ì˜í•  ìˆ˜ ìˆìœ¼ë©°,  
   ì—¬ê¸°ì—ì„œ ì‹¤í–‰í•  ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
   ê·¸ë¦¬ê³  ë‹¤ìŒ ê°’ì´ ë°©ì¶œë˜ê¸°ë¥¼ ê¸°ë‹¤ë¦½ë‹ˆë‹¤.  
   ì—¬ê¸°ì„œ ì–»ëŠ” ê°’ì€ ì‘ë‹µ ë°ì´í„° ëŒ€ì‹   
   ì´ë²¤íŠ¸ íƒ€ì…ì˜ ê°’ì´ ë©ë‹ˆë‹¤.

---

8. **But this event value actually will have a type field  
   which we can use in a if check  
   to check if the event type is HTTP event type,  
   which must be imported from Angular common http.response.**  
   í•˜ì§€ë§Œ ì´ ì´ë²¤íŠ¸ ê°’ì—ëŠ”  
   `type` í•„ë“œê°€ í¬í•¨ë˜ì–´ ìˆì–´  
   `if` ì¡°ê±´ë¬¸ì—ì„œ ì´ë²¤íŠ¸ íƒ€ì…ì´ HTTP ì´ë²¤íŠ¸ íƒ€ì…ì¸ì§€  
   í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
   ì´ íƒ€ì…ì€ Angular `common/http.response`ì—ì„œ  
   ì„í¬íŠ¸í•´ì•¼ í•©ë‹ˆë‹¤.

---

9. **And as you see, there are other kinds of events  
   that could be emitted as well.  
   For example, if a request was just sent,  
   if you wanted to listen to that and execute code,  
   you could do it with the sent event type.**  
   ê·¸ë¦¬ê³  ë³´ì‹œë‹¤ì‹œí”¼,  
   ë°©ì¶œë  ìˆ˜ ìˆëŠ”  
   ë‹¤ë¥¸ ì¢…ë¥˜ì˜ ì´ë²¤íŠ¸ë„ ìˆìŠµë‹ˆë‹¤.  
   ì˜ˆë¥¼ ë“¤ì–´, ìš”ì²­ì´ ë°©ê¸ˆ ì „ì†¡ë˜ì—ˆì„ ë•Œ  
   ì´ë¥¼ ê°ì§€í•˜ê³  ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë ¤ë©´,  
   `sent` ì´ë²¤íŠ¸ íƒ€ì…ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

10. **But here I'm interested if the event  
    that was in the end emitted by this observable  
    is of type response,  
    which means we're dealing with the response here.**  
    í•˜ì§€ë§Œ ì—¬ê¸°ì„œëŠ”  
    ì´ Observableì´ ë°©ì¶œí•œ ì´ë²¤íŠ¸ê°€  
    ì‘ë‹µ(`response`) íƒ€ì…ì¸ì§€ì— ê´€ì‹¬ì´ ìˆìŠµë‹ˆë‹¤.  
    ì´ëŠ” ìš°ë¦¬ê°€ ì‘ë‹µì„  
    ì²˜ë¦¬í•˜ê³  ìˆìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

ì•Œê² ìŠµë‹ˆë‹¤! ìš”ì²­í•˜ì‹  ë°©ì‹ëŒ€ë¡œ ê³„ì† ì§„í–‰í•˜ê² ìŠµë‹ˆë‹¤.

---

11. **And in that case, I'll simply log incoming response  
    and then log event status and maybe also the body like this,  
    which will be the response status code  
    and the response body.**  
    ê·¸ë¦¬ê³  ì´ ê²½ìš°ì—ëŠ” "Incoming Response"ë¥¼ ë¡œê·¸ë¡œ ì¶œë ¥í•˜ê³ ,  
    ì´ë²¤íŠ¸ ìƒíƒœì™€ ë³¸ë¬¸ì„ ë¡œê·¸ë¡œ ì¶œë ¥í•˜ê² ìŠµë‹ˆë‹¤.  
    ì´ë•Œ ìƒíƒœëŠ” ì‘ë‹µ ìƒíƒœ ì½”ë“œì´ê³ ,  
    ë³¸ë¬¸ì€ ì‘ë‹µ ë³¸ë¬¸ì´ ë  ê²ƒì…ë‹ˆë‹¤.

---

12. **And that's how you can set up a response interceptor.**  
    ì´ê²ƒì´ ì‘ë‹µ ì¸í„°ì…‰í„°ë¥¼ ì„¤ì •í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.

---

13. **With that done, if you reload,  
    you got some logs here,  
    for example, the incoming response log,  
    the status code, and then the response body,  
    which is of course this array of places.**  
    ì„¤ì •ì„ ì™„ë£Œí•˜ê³  ìƒˆë¡œê³ ì¹¨í•˜ë©´  
    ëª‡ ê°€ì§€ ë¡œê·¸ê°€ í‘œì‹œë©ë‹ˆë‹¤.  
    ì˜ˆë¥¼ ë“¤ì–´, "Incoming Response" ë¡œê·¸,  
    ìƒíƒœ ì½”ë“œ, ê·¸ë¦¬ê³  ì‘ë‹µ ë³¸ë¬¸ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.  
    ì‘ë‹µ ë³¸ë¬¸ì€ ë¬¼ë¡   
    ì¥ì†Œ ë°°ì—´ì´ ë©ë‹ˆë‹¤.

---

14. **In this case of the user places  
    because that was the first response to arrive.**  
    ì´ ê²½ìš°, ì‚¬ìš©ì ì¥ì†Œì™€ ê´€ë ¨ëœ ì‘ë‹µì…ë‹ˆë‹¤.  
    ì´ëŠ” ì²« ë²ˆì§¸ë¡œ ë„ì°©í•œ ì‘ë‹µì´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

---

15. **And that's therefore how you can register  
    such response interceptors  
    in combination with request interceptors.**  
    ë”°ë¼ì„œ ì´ê²ƒì´  
    ìš”ì²­ ì¸í„°ì…‰í„°ì™€ ê²°í•©í•˜ì—¬  
    ì‘ë‹µ ì¸í„°ì…‰í„°ë¥¼ ë“±ë¡í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.

---

### ë²ˆì—­ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!
ì¶”ê°€ ìš”ì²­ ì‚¬í•­ì´ ìˆìœ¼ë©´ ì–¸ì œë“  ë§ì”€í•´ì£¼ì„¸ìš”. ğŸ˜Š
