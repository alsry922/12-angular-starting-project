1. **So how can we tweak this code here**  
   **to make sure that we don't run into**  
   **any optimistic updating problems?**  
   그렇다면, 낙관적 업데이트에서 발생할 수 있는 문제를  
   어떻게 해결할 수 있을까요?

2. **Well, there of course, again, are different options,**  
   **but one way would be to again use the pipe method**  
   **to add some operators to this observable chain here.**  
   여러 가지 방법이 있겠지만,  
   하나의 방법은 `pipe` 메서드를 사용해  
   옵저버블 체인에 연산자를 추가하는 것입니다.

3. **And then we could add the catchError operator here**  
   **to handle potential errors that occur on the backend.**  
   여기에서 `catchError` 연산자를 추가해  
   백엔드에서 발생할 수 있는 오류를 처리할 수 있습니다.

4. **Here we then get that error object**  
   **that's generated by Angular**  
   **if that request causes an error**  
   **and then we can decide how we want to handle it.**  
   요청이 오류를 일으키면  
   Angular가 생성한 오류 객체를 받을 수 있고,  
   이를 어떻게 처리할지 결정할 수 있습니다.

5. **Now I will return a new observable generated**  
   **with throwError.**  
   **And for that you must make sure that this is imported**  
   **because this catchError operator always wants a new**  
   **observable being returned inside of it.**  
   이제 `throwError`를 사용해  
   새 옵저버블을 반환할 것입니다.  
   이 연산자를 사용하려면  
   반드시 `throwError`를 가져와야 합니다.  
   `catchError` 연산자는 항상  
   새 옵저버블을 반환해야 하기 때문입니다.

6. **So I'll quickly create a new error here**  
   **to make sure that this is the case.**  
   **And the error message could be**  
   **"Failed to store selected place."**  
   여기서 "선택한 장소를 저장하지 못했습니다"라는  
   새 오류 메시지를 만들어 처리할 것입니다.

7. **But that's actually not the main thing I want to do in here.**  
   **Instead, I also want to make sure**  
   **that I roll back my optimistic update here**  
   **if something goes wrong.**  
   하지만, 여기서 주된 목표는 그것이 아닙니다.  
   대신, 문제가 발생하면 낙관적 업데이트를  
   롤백(되돌리기)하도록 설정하는 것이 목표입니다.

8. **And one way of achieving this would be**  
   **to go here into catchError**  
   **and to update the userPlaces signal here as well.**  
   이를 달성하는 방법 중 하나는  
   `catchError` 내부에서 `userPlaces` 시그널을  
   업데이트하는 것입니다.

9. **To do that, I'll actually change my code up here**  
   **and I'll get my previous places**  
   **before we performed the optimistic updating**  
   **by simply reading my signal.**  
   이를 위해, 위의 코드를 수정하고,  
   낙관적 업데이트를 수행하기 전에  
   시그널을 읽어 이전 장소 데이터를 가져옵니다.

10. **As you learned before, this will not set up a subscription,**  
    **it will just read the value once.**  
    앞서 배운 것처럼, 이 작업은  
    구독을 설정하지 않고  
    값을 한 번만 읽습니다.

11. **Therefore here we can also simplify this code**  
    **and not call update,**  
    **but just set the observable to this new array like this.**  
    따라서 이 코드를 간소화하여  
    `update`를 호출하지 않고  
    새 배열로 값을 설정할 수 있습니다.

12. **That's an alternative to using this update method.**  
    **And if we now have an error, we can take advantage**  
    **of this previous places constant,**  
    **which holds the old places**  
    **before we updated them,**  
    **to roll back to those previous places.**  
    이는 `update` 메서드를 사용하는  
    대안입니다.  
    이제 오류가 발생하면,  
    업데이트 전에 저장된  
    `previousPlaces` 상수를 사용해  
    이전 상태로 롤백할 수 있습니다.

13. **With that, if you save that,**  
    **here in this app**  
    **where we still have this error response on the backend,**  
    **if I add a place, you see it only appears here briefly**  
    **until that error is caught and then it's rolled back,**  
    **and that's of course better than what we had before.**  
    이 변경사항을 저장한 뒤,  
    백엔드에서 오류 응답이 설정된 상태로  
    장소를 추가하면,  
    오류가 감지되고 롤백되기 전까지만  
    화면에 잠깐 나타납니다.  
    이는 이전보다 훨씬 나은 결과입니다.

14. **In addition, I want to make sure**  
    **that we can't add a place we already added before.**  
    추가적으로, 이미 추가된 장소를  
    중복해서 추가하지 못하도록 설정하고자 합니다.

15. **Therefore, I'll add a check here**  
    **and check if in our previous places**  
    **we have some place using the built-in some method,**  
    **which is built into JavaScript and can be called on array,**  
    **and that then wants a function**  
    **which will automatically receive**  
    **every array element as an input.**  
    이를 위해, JavaScript의 배열 메서드인  
    `some` 메서드를 사용해,  
    이전 장소 데이터에 동일한 장소가 있는지  
    확인하는 코드를 추가하겠습니다.

16. **And you then must return true**  
    **if some overall should yield true,**  
    **and false otherwise.**  
    이 함수는 전체 배열 중  
    하나라도 조건에 부합하면 `true`,  
    그렇지 않으면 `false`를 반환합니다.

17. **So here I'll check if in my previous places**  
    **I have at least some place**  
    **where the ID is equal to the ID**  
    **of the place I'm about to add.**  
    그래서 이전 장소 데이터 중  
    추가하려는 장소와 ID가 동일한  
    항목이 있는지 확인합니다.

18. **And then I wanna check if that's actually not the case.**  
    **So if some yields false,**  
    **which means we have no place in the entire existing places**  
    **array that has the same ID as the place I'm about to add**  
    **because only in that case I wanna update my userPlaces.**  
    그런 다음, `some` 메서드가 `false`를 반환하는지  
    확인합니다.  
    이는 전체 배열에서  
    추가하려는 장소와 동일한 ID를 가진  
    항목이 없음을 의미합니다.  
    이 경우에만 `userPlaces`를 업데이트합니다.

19. **And with that, we should make sure**  
    **that we don't have duplicate places in our application.**  
    이를 통해, 애플리케이션에서  
    장소가 중복 추가되지 않도록 설정할 수 있습니다.

20. **So now if I reload**  
    **and I try to add a place that's already part**  
    **of the favorite places like the Amazon River,**  
    **I can hammer it and it still doesn't show up down there.**  
    이제 새로고침한 후,  
    이미 즐겨찾기에 추가된 장소(예: 아마존 강)를  
    추가하려고 해도,  
    중복 항목이 추가되지 않습니다.

21. **And with that, we improved this optimistic updating**  
    **and we make sure that we don't update the UI in a way**  
    **that's then not in sync with the backend.**  
    이를 통해 낙관적 업데이트를 개선하고,  
    UI가 백엔드와 동기화되지 않는 방식으로  
    업데이트되지 않도록 보장할 수 있습니다.

22. **Of course, with that,**  
    **we can therefore also go to the backend**  
    **and get rid of that error,**  
    **which I added to this put route**  
    **since it was only there for demo purposes.**  
    이제 백엔드의 `PUT` 라우트에 추가했던  
    데모용 오류 코드를 제거할 수 있습니다.

23. **And you should restart the backend server**  
    **after editing the code.**  
    코드를 수정한 뒤에는  
    백엔드 서버를 재시작해야 합니다.

24. **With that, if you reload again, you'll see that again,**  
    **if you try to add a place**  
    **that is already part of the places, it doesn't work.**  
    그런 다음, 다시 새로고침하면,  
    이미 추가된 장소를 다시 추가하려 해도  
    동작하지 않는 것을 확인할 수 있습니다.

25. **Also after reloading, it's still only here once.**  
    **And if you add a place that's not part down there,**  
    **it does show up instantly here**  
    **and it's still there if you reload.**  
    새로고침한 뒤에도  
    중복 항목은 하나만 존재하며,  
    새로운 장소를 추가하면 즉시 표시되고,  
    새로고침 후에도 유지됩니다.

26. **And that's how you can perform**  
    **optimistic updating with Angular.**  
    이것이 Angular에서

낙관적 업데이트를  
수행하는 방법입니다.

27. **It's one way, there would be others,**  
    **but it is a way that's hopefully quite straightforward**  
    **to implement.**  
    다른 방법도 있을 수 있지만,  
    이 방법은 비교적 간단히 구현할 수 있는 방법입니다.  
